# CPU 스케쥴링에 대해 알려주세요.

[스티치의 스케쥴링](stitch.md)

[비밥의 스케쥴링](bebop.md)

[엘리의 스케줄링](elly-scheduling.md)

---

### 스케줄링이란

Ready queue 중에서 실행시킬 프로세스를 하나 선택하는 것을 스케줄링이라고 한다.

<br/>

### 스케줄링 기준

스케줄링 알고리즘이 어떤 일을 처리하는 것이 더 좋은지를 평가하는 기준을 말한다.

#### 1. CPU utilization

CPU가 놀지 않고 얼마나 많이 사용되고 있는지를 말한다. CPU가 비싼 자원이라 CPU가 노는 일 없이 많이 일을 할 수 있도록 하는 것이 좋은 알고리즘이다.

#### 2. Throughput

단위 시간당 처리하는 일의 양을 의미한다.

#### 3. Turnaround time

수행 요청이 들어간 후 끝날 때까지의 시간을 말한다. 빨리 끝날수록 좋은 알고리즘이다.

#### 4. Waiting time

수행 요청이 들어갔는데 다른 프로세스가 실행 중이여서 기다려야하는 시간을 말한다. ready queue에서 running이 되기 위해 기다리는 시간을 말한다.

I/O 요청과 같은 이유로 기다리는 시간이 아니라 다른 프로세스 때문에 기다리게 되는 시간을 말한다.

#### 5. Response time

작업이 어떻게 진행되고 있는지에 대한 응답을 주는 시간을 말한다.

<br/>

### 프로세스의 생명주기

준비 / 대기 / 실행 / 종료

![image](https://user-images.githubusercontent.com/19922698/89120971-beb79600-d4f5-11ea-8466-d08172317577.png)

<br/>



## 선점 스케줄링

프로세스가 CPU를 할당받아 실행 중이더라도, OS가 CPU를 강제로 뺏을 수 있다. (우선순위가 높다면)

:thumbsup: CPU 처리 시간이 매우 긴 프로세스가 CPU 독점하는 것을 막을 수 있다.

:thumbsup: 우선순위가 높은 프로세스를 빠르게 처리할 때 유용하다.

:thumbsdown: context switching이 잦아 오버헤드가 자주 발생한다.

<br/>

#### SRTF(Shortest Remaining Time First)

먼저 온 프로세스가 CPU를 할당받고 있어도, `남은 처리시간`이 `뒤에 온 프로세스의 처리시간`보다 크면 뒤에 온 프로세스에게 CPU를 빼앗긴다.

선점형 방식에 소요시간이 짧은 작업을 우선하여 처리하기 때문에 기아 현상이 발생할 수 있다.

<br/>

#### Round Robin

현재 우리의 운영체제는 Priority (+aging) + RR의 형태로 스케줄링이 진행되고 있다.

프로세스가 기다리는 시간이 CPU를 사용할 만큼 증가하므로 공정한 스케줄링이라고 할 수 있다.

RR에서는 time quantum이라는 개념이 존재하는데 일을 끝내야 할 프로세스마다 얼만큼 시간동안 머물러서 작업을 하고 교체할 것인지를 말한다.

프로세스에게 각각 동일한 CPU 할당 시간을 부여해서 이 시간동안만 CPU를 사용하게 한다. 다 처리하지 못하면 뺏기고, 다음 순서가 돌아왔을 때 마저 처리한다. 뺏긴 프로세스는 준비 큐의 맨 뒤(Tail)로 간다.

그러나 설정한 `time quantum`이 너무 커지면 `FCFS`와 같아진다. 또 너무 작아지면 스케줄링 알고리즘의 목적에는 이상적이지만 잦은 context switch 로 overhead 가 발생한다. 그렇기 때문에 적당한 `time quantum`을 설정하는 것이 중요하다.

n 개의 프로세스가 준비 큐에 있고, 할당 시간이 q (`time quantum`) 인 경우, 각 프로세스는 q 단위로 CPU 시간의 1/n을 얻는다. 즉, 어떤 프로세스도 (n-1) * q 시간 이상을 기다리지 않는다.

<br/>

## 비선점 스케줄링

프로세스가 CPU를 점유하고 있다면 이를 뺴앗을 수 없다.

:thumbsup: 오버헤드가 상대적으로 적다.

:thumbsdown: CPU 처리 시간이 매우 긴 프로세스가 CPU 독점하는 것을 막을 수 없다.

<br/>

#### FCFS (First Come First Served)

말 그대로 들어오는 순서대로 처리하는 알고리즘이다. 이 알고리즘은 제일 **공평한 알고리즘**이다. starvation이 없다는 장점이 있다.

그러나 burst(수행 시간)가 큰 작업이 먼저 들어오게 되면 average waiting time 측면에서 좋지 않다.

> burst가 10, 5, 3인 순서대로 들어왔다면 waiting time은 0 + 10 + 15 = 25이다. 3으로 나누면 평균 waiting ime은 약 8 정도가 된다.
>
> 만약 3, 5, 10의 순서로 들어온다면 waiting time이 0 + 3 + 5 = 8이여서 평균 2에서 3정도의 waiting time을 가진다.

이러한 현상을 convey effect라고 부른다.

<br/>

#### SJF(Shortest Job First Scheduling)

이 알고리즘은 수행 시간이 짧은 작업을 우선적으로 처리하는 작업이다. FIFO가 가지는 단점을 보완하기 위해서 나온 알고리즘이기 때문에 average waiting time이 가장 적게 걸린다.

**어려운 점은 프로세스가 가지는 burst를 미리 알 수 없기 때문에 실제로 적용하기가 어렵다.** 그래서 기다리고 있는 작업 중 수행시간이 가장 짧다고 판단되는 작업을 먼저 수행하도록 한다.

<br/>

#### Priority Scheduling

우선순위가 높은 작업에게 CPU 를 할당하겠다.  
우선순위는 정수로 표현하고 숫자가 작을수록 우선순위가 높다.

선점형 방식과 비선점형 방식 두가지가 있다.

**선점형 스케줄링 방식의 경우**
더 높은 우선순위의 작업 도착하면 실행중인 작업을 멈추고 CPU 를 선점한다.

**비선점형 스케줄링 방식의 경우**
더 높은 우선순위의 작업이 도착하면 Ready Queue 의 Head 에 넣는다. (현재 실행중인 작업이 끝나면 바로 처리하도록!)

마찬가지로 기아 현상이 발생할 수 있다.

그리고 무기한 봉쇄가 발생할 수 있다.

> 실행 준비는 되어있으나 CPU 를 사용못하는 프로세스를 CPU 가 무기한 대기하는 상태

이러한 문제는 aging으로 해결할 수 있다.

>aging
>우선순위가 낮은 작업이 오래 기다리면 우선순위를 높여주는 알고리즘

