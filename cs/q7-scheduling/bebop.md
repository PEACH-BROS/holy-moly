# CPU 스케쥴링에 대해 알려주세요.

프로세스(이하 작업)를 스케줄링하기 위한 Queue 에는 세 가지 종류가 존재한다.

- Job Queue : 현재 시스템 내에 있는 모든 작업의 집합
- **Ready Queue : 현재 메모리 내에 있으면서 CPU 를 잡아서 실행되기를 기다리는 작업의 집합**
- Device Queue : Device I/O 작업을 대기하고 있는 작업의 집합

위 세 종류의 Queue중 **Ready Queue에 CPU 스케쥴링이 적용**된다.

### CPU 스케쥴링 종류

#### FCFS(First Come First Served)

일반적인 Queue의 형태로 먼저 Queue에 들어온 작업을 우선하여 처리한다.

따라서 비선점형 방식의 스케쥴링이다.

시간이 오래 소요되는 작업이 먼저 들어온 경우 효율이 낮아질 수 있다.

#### SJF(Shortest - Job - First)

작업시간이 짧은 순서의 작업을 먼저 처리하는 방식이다.

비선점형 방식의 스케쥴링이다.

위 스케쥴링은 시간이 오래 걸리는 작업은 무한히 대기하는 기아 현상이 발생할 수 있다.

#### SRT(Shortest Remaining time First)

새로운 작업이 들어올 때 마다 작업의 소요시간을 다시 계산하는 방식이다.  
진행중인 작업보다 새로 들어온 작업의 소요시간이 짧으면 새로 들어온 작업을 처리한다.

따라서 선점형 방식의 스케쥴링이다.

선점형 방식에 소요시간이 짧은 작업을 우선하여 처리하기 때문에 기아 현상이 발생할 수 있다.

#### Priority Scheduling

우선순위가 높은 작업에게 CPU 를 할당하겠다.  
우선순위는 정수로 표현하고 숫자가 작을수록 우선순위가 높다.

선점형 방식과 비선점형 방식 두가지가 있다.

선점형 스케줄링 방식의 경우
더 높은 우선순위의 작업 도착하면 실행중인 작업을 멈추고 CPU 를 선점한다.

비선점형 스케줄링 방식의 경우
더 높은 우선순위의 작업이 도착하면 Ready Queue 의 Head 에 넣는다. (현재 실행중인 작업이 끝나면 바로 처리하도록!)

마찬가지로 기아 현상이 발생할 수 있다.

그리고 무기한 봉쇄가 발생할 수 있다.

> 실행 준비는 되어있으나 CPU 를 사용못하는 프로세스를 CPU 가 무기한 대기하는 상태

이러한 문제는 aging으로 해결할 수 있다.

>aging
>우선순위가 낮은 작업이 오래 기다리면 우선순위를 높여주는 알고리즘

#### Round Robin

현대적인 CPU 스케줄링이다.

각 작업 동일한 크기의 할당 시간(time quantum)을 갖게 되고, 할당 시간이 지나면 작업은 선점당하고 Ready Queue 의 제일 뒤에 가서 다시 줄을 선다.

`RR`은 CPU 사용시간이 랜덤한 작업들이 섞여있을 경우에 효율적이다.  
`RR`이 가능한 이유는 작업들의 context 를 save 할 수 있기 때문이다.

`Response time`이 빨라진다.
n 개의 작업이 ready queue 에 있고 할당시간이 q(time quantum)인 경우 각 작업은 q 단위로 CPU 시간의 1/n 을 얻는다. 즉, 어떤 작업도 (n-1)q time unit 이상 기다리지 않는다.

작업이 기다리는 시간이 CPU 를 사용할 만큼 증가한다.
공정한 스케줄링이라고 할 수 있다.

그러나 설정한 `time quantum`이 너무 커지면 `FCFS`와 같아진다. 또 너무 작아지면 스케줄링 알고리즘의 목적에는 이상적이지만 잦은 context switch 로 overhead 가 발생한다. 그렇기 때문에 적당한 `time quantum`을 설정하는 것이 중요하다.