# 메모리 단편화 (Memory Fragmentation)

#### 나의 답변 

메모리 사용이 부분적으로 해제되어 군데군데 빈 공간이 발생한 상태! 특정 객체를 할당할 수 있는 메모리가 분명 존재하지만, 객체를 할당하지 못하는 경우에 메모리 단편화가 발생했다고 한다.



# 메모리 단편화

RAM에서 메모리 공간이 작은 조각으로 나뉘어져 사용 가능한 메모리가 충분히 존재하지만, 할당(사용)이 불가능한 상태



`내부 단편화`와 `외부 단편화` 두 가지로 나뉜다.



## 내부 단편화

**특정 프로세스가 필요 이상으로 메모리를 할당받아서, 메모리 공간이 낭비되는 상황**

ex) 메모장을 켰는데 OS가 4KB를 할당해줬다. 그런데 사실은 1KB만 사용하고 있다. (필요 이상으로 메모리를 할당받았다)

![image](https://user-images.githubusercontent.com/19922698/85363300-84082880-b55b-11ea-8bfc-5f8ef596cd3d.png)

## 외부 단편화

**메모리 중간중간에 생긴 사용하지 않는 메모리가 많이 존재해서 총 메모리 공간은 충분하지만 실제로 할당할 수 없는 상황**

ex) 메모리에 8MB짜리 프로세스가 할당되었고, 이어서 16MB가 할당되었다. 그리고 8MB짜리 프로세스가 종료되면 시작 주소부터 8MB만큼 빈 공간이 생긴다.

![image](https://user-images.githubusercontent.com/19922698/85363320-95513500-b55b-11ea-880d-ae47648892f5.png)

# 메모리 단편화 문제 해결 방법

## 1. 압축

메모리 공간을 **재배치**하여, 단편화로 인해 분산되어 있는 메모리 공간들을 하나로 합친다.

<br>

## 2. 통합

단편화로 인해 분산된 메모리 공간들을 인접한 것끼리 통합시킨다. 압축은 재배치가 일어나지만, 통합은 인접한 공간끼리 통합된다.

<br>

## 3. 세그먼테이션 기법

`가상메모리 사용`, `내부 단편화 해결`

가상메모리를 서로 *다른* 크기의 세그먼트로 분할해서 메모리 할당 후, 실제 메모리 주소로 변환

각 세그먼트는 연속적인 공간에 저장되어 있으며, 매핑을 위해 segment table이 필요하다.

세그먼트의 크기가 다 다르기 때문에, 페이징 기법처럼 메모리를 미리 분할해 둘 수 없고, 메모리가 적재될 때 빈 공간을 찾아 할당한다.

❓세그멘테이션 기법이 어떻게 내부 단편화를 해결하지?

❗️메모리는 byte 단위가 아니라 시스템 block 단위로 할당되고, block의 크기는 시스템마다 다르다. 예를 들어, 1 block = 1 KB인 시스템이 있다. 프로세스가 14.3KB를 요청하면 시스템은 블록 단위로 15KB만큼 할당해준다. 이렇게 되면 0.7KB의 메모리 낭비가 일어나게 된다.



단, 프로세스가 필요한 메모리 공간만큼 할당해주기 때문에, 내부단편화 문제는 일어나지 않지만, 중간에 메모리를 해제하면 생기는 외부단편화 문제는 여전히 발생한다.

<br>

## 4. 페이징 기법

`가상메모리 사용`, `외부 단편화 해결`

페이지: 가상메모리를 같은 크기의 블록으로 나눈 것

프레임: RAM(흔히 말하는 메모리)을 같은 크기의 블록으로 나눈 것 (페이지와 같은 크기)



사용하지 않는 프레임을 페이지(가상 메모리)에 옮기고, 필요한 메모리를 페이지 단위로 프레임에 옮기는 기법. 

![image](https://user-images.githubusercontent.com/19922698/85364673-9d5ea400-b55e-11ea-9121-4abe528507a3.png)

▶️ 물리 메모리(프레임)와 가상 메모리(페이지)를 대응하기 위해 page mapping 과정이 필요하다. 이를 위해 paging table을 설정한다.

▶️ 연속적이지 않은 공간도 활용할 수 있기 때문에 외부 단편화를 해결할 수 있다.

❗️페이지 단위를 작게 하면 내부 단편화 역시 해결할 수 있지만, 그만큼 page mapping 과정이 증가하기 때문에 **trade off**이다.

<br>

## 5. 메모리 풀

`내부 단편화 해결`, `외부 단편화 해결`

동적 할당과 비슷한 개념.

필요한 메모리 공간을 필요한 크기/개수만큼 사용자가 직접 지정해 미리 할당받아 놓고, 필요할 때마다 사용/반납하는 기법.

미리 할당받아서 메모리 풀을 만들어 놓는다.

메모리 풀 없이 할당/해제를 반복하면 랜덤한 위치에 할당/해제가 반복되어 단편화를 일으킬 수 있지만, 메모리 풀 방식은 미리 공간을 할당해두기 때문에 

필요한 크기만큼 할당한다 -> 내부 단편화 해결

미리 공간을 할당해둔다 -> 외부 단편화 해결







> 참고
>
> https://jeong-pro.tistory.com/91  
> https://junsday.tistory.com/36  
> https://sycho-lego.tistory.com/10  
> https://baked-corn.tistory.com/16  
> https://kyoun.tistory.com/31



