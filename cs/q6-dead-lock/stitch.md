# 데드락(Deadlock)이 뭔가요? 해결 방법은?

![deadlock](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=http%3A%2F%2Fcfile9.uf.tistory.com%2Fimage%2F99471C465A31252E1DB9A6)

## 데드락(*Deadlock*)이란

서로가 상대방이 자원을 내놓기를 바라면서 무기한 연기 상황에 빠지는 것이다. 이는 **다양한 유형의 자원을 대상으로 경쟁**하는 여러 프로세스 때문에 발생한다.

하나 또는 둘 이상의 프로세스가 더 이상 계속할 수 없는 어떤 특정 사건(자원의 할당과 해제)을 기다리고 있는 상태를 말한다.

> 프로세스 A가 자원 1,2번을 사용하여 작업을 처리하려고 한다. 자원 1은 가져왔는데 자원 2를 가져오려고 하니 프로세스 B가 자원 2를 사용하고 있다. 프로세스 A는 프로세스 B가 작업을 처리하기를 기다린다.
>
> 프로세스 B 또한 자원 1, 2번을 사용해서 작업을 처리해야 한다. 자원 2는 가져왔지만 자원 1은  프로세스 A가 사용하고 있다. 프로세스 A가 작업을 마치고 자원 1을 반환할 때까지 기다린다.
>
> 이렇게 서로 자원이 반환되기를 기다리고만 있는 상황이 교착상태, 데드락(deadlock)이다.

멀티 스레드 상황에서는 하나의 자원을 공유하려는 경우가 많아서 데드락 발생 가능성이 크다. 이때 말하는 자원, 일정 시간동안 여러 프로세스에서 사용하지만 한 순간에서는 한 프로세스에서만 사용하는 자원을 **세마포어**라고 부른다.



## 데드락(*Deadlock*) 발생 조건

데드락이 발생하기 위해서는 4가지 필요 조건이 존재한다.

> **필요 조건**이기 때문에 단 하나라도 만족하지 않는다면 데드락이 발생하지 않는다.

### 1. 상호 배제 : *Mutual Exclusion*

프로세스들이 자원을 배타적으로 점유, 다른 프로세스들이 자원 사용이 불가능하다. 

한 번에 한 프로세스만이 자원 사용 가능하다(세마포어).

### 2. 점유 & 대기 : *Hold and Wait*

부분 할당, 다른 종류의 자원을 부가적으로 요구하면서 이미 어떤 자원을 점유하고 있다.

> **철학자 문제**가 대표적인 예시이다.
>
> 왼쪽에 있는 포크을 집은 상태에서 오른쪽에 있는 포크를 집으려고 하니 이미 오른쪽 포크를 옆 사람이 사용하고 있는 상황 발생한다. 이 상황, 자신이 쓰고 있으면서 다른 것을 또 점유하려는 상황이 hold and wait 이다.

### 3. 비선점 : *No Preemption*

자원들은 그들이 점유하고 있는 프로세스로부터 도중에 반환되지 않는다.

프로세스가 더 이상 진행되지 않아서 자신이 점유하고 있는 자원을 반환하면 preemption, 반환하지 않는다면 no preemtion이다.

### 4. 환형대기 : *Circular wait*

프로세스와 자원들이 원형을 이루며, 각 프로세스가 자신에게 할당된 자원을 가지면서 다른 프로세스의 자원을 요청하는 경우이다.

간단하게 사이클이 발생한 구조라고 생각할 수 있다.



## 데드락(*Deadlock*) 처리 방법

### 1. 예방 : *Prevention*

데드락이 발생될 가능성을 아예 예방하자는 것이다. 데드락이 발생하지 않는 알고리즘을 만든다거나 하는 방법으로 설계하는 것도 해당된다.

예방은 프로그램을 개발하는 개발자의 역할이다.

### 2. 회피 : *Avoidance*

데드락이 발생할 가능성이 있는지 여부를 운영체제가 검사만 하고 발생하지 않을 경우에만 자원을 줘서 문제 발생을 피하는 방법이다.

매 시점마다 전체 할당된 프로세스를 파악하고 데드락이 발생할 수 있는 상황인지 판단을 해야하는데 이는 더 오버헤드를 크게 만드는 문제가 있다.

### 3. 감지 & 복구 : *Detection and Recovery*

데드락 프로세스들을 모두 중지하는 방법 또는 한 프로세스씩 중지하는 방법이 있다.

> 희생자 선택의 원칙 : 최소 비용으로 중지시키는 방법을 찾는 것.

이는 운영체제가 달라는 대로 자원을 다 주고 주기적으로 데드락이 발생했는지 여부를 검사한다. 데드락 발생을 감지(detect)하면 데드락이 발생하기 전으로 복구(recover)하는 것이 detection and recovery이다.

복구를 하는 방법으로 하나의 프로세스를 죽이거나 모든 프로세스를 중지시키는 방법이 존재한다.

이 방법 또한 데드락이 발생했는지 확인해야 하고 그 알고리즘도 엄청나게 복잡하기 때문에 큰 오버헤드를 가진다.

### 4. 아몰랑 : *Do Nothing*

''그냥 너가 알아서 해, 난 모르겠어'가 현재 운영체제가 유지하고 있는 방법이다.

개발자가 처음 프로그램을 만들 때부터 이를 봉쇄하도록 만들어야 한다. 



## 데드락(Deadlock) 회피 알고리즘 - 은행원 알고리즘(Banker's Algorithm)

### 은행원 알고리즘 : *Banker's Algorithm*

다익스트라 알고리즘을 개발한 Edsger Dijkstra가 개발한 알고리즘이다.

데드락이 발생할 수 있는 가능성을 판단하기 위해 상태를 안전 상태(safe state)와 불안전 상태(unsafe state)로 나눈다.

은행원 알고리즘은 안정 상태를 유지할 수 있는 요구만을 수락하고 불안전 상태를 발생시킬 수 있는 요구는 나중에 안전 상태를 만족할 수 있을 때까지 계속 거절한다.

> 은행에서의 상황을 예시로 들어보자.
>
> 현재 은행에서는 100만원을 소유하고 있다. 돈을 빌리려는 사람은 3명(고객1, 고객2, 고객3)이 있고 이들은 돈을 빌려주면 상황을 해결하고 바로 갚을 수 있는 능력이 된다. 이때, 고객 1은 60만원, 고객 2는 40만원, 고객 3은 50만원이 필요하다고 가정해보자.
>
> 은행이 고객 1, 2, 3에게 각각 20만원, 30만원, 30만원씩 돈을 빌려주었다. 그렇다면 총 80만원의 돈을 고객들에게 빌려주게 되었고 은행이 가지고 있는 잔액은 20만원이 된다.
>
> 이때 은행에서 고객 1에게 남은 20만원을 빌려주면 어떤 상황이 발생할까?
>
> 고객 1은 40만원을 가지고 있고 20만원이 부족하다. 나머지 고객 2와 3은 이전과 동일한 상황이므로 결국 고객 1, 2, 3 모두 문제를 해결하고 돈을 다시 은행에 돌려줄 수 없게 된다. 이런 상황이 앞서 말한 **불안전 상태**이다. 여기서 말하는 불안정 상태가 곧 **데드락**을 의미한다. 은행은 이러한 상황이 발생하지 않도록 돈을 빌려주어야 한다.
>
> 다시 이전으로 돌아가서 고객 1에게 20만원을 빌려주는 것이 아니라 고객 2에게 필요한 돈 10만원만 빌려준다면 어떻게 될까? 고객 2는 이전에 30만원을 빌렸다가 추가로 10만원을 더 빌려 40만원을 가지게 된다. 이는 고객 2가 상황을 해결할 수 있는 금액이기 때문에 이후 은행은 다시 돈을 돌려받을 수 있게 되므로 고객 2에게 돈을 빌려주는 상황은 **안전 상태**라 볼 수 있다.
>
> 이후 40만원을 돌려받았기에 은행이 가지고 있는 돈은 50만원이 되고, 이는 고객 1 또는 고객 3에게 원하는 금액만큼 빌려주더라도 항상 안정 상태를 유지할 수 있게 된다.
>
> 즉, 은행원 알고리즘은 최소한 고객 한 명에게 대출해줄 금액은 항상 은행이 보유하고 있어야 한다는 개념이다. 이는 다시 말하자면 항상 안전 상태를 보장할 수 있도록 하는 방법이다.

### 안전 상태 : *Safe State*

시스템이 데드락을 발생시키지 않으면서 각 프로세스가 요구한 최대 요구량만큼 자원을 할당해줄 수 있는 상태로 안전 순서열이 존재하는 상태를 말한다.

> 안전 순서열은 해당하는 순서대로 프로세스를 진행하면 안전하게 마칠 수 있는 순서를 의미한다.

### 불안전 상태 : *Unsafe State*

안전 순서열이 존재하지 않는 상태를 말한다. 불안전 상태는 데드락이기 위한 필요조건이다. 데드락은 불안전 상태에서만 발생한다. 그렇다고 불안전 상태일때 무조건 데드락이 발생하는 것은 아니다.

### 은행원 알고리즘이 수행되기 위한 3가지 조건

1. 고객들이 얼마나 최대한으로 돈을 요구할지 : **Max**
2. 고객들이 현재 빌린 돈은 얼마인지 : **Allocated**
3. 은행이 보유한 돈이 얼마인지, 빌려줄 수 있는 돈이 얼마인지 : **Available**

### 은행원 알고리즘의 단점

- 할당할 수 있는 자원의 수가 일정해야 한다.
- 사용자 수가 일정해야 한다.
- 항상 불안전 상태를 방지해야 하므로 자원 이용도가 낮다.
- 최대 자원 요구량을 미리 알아야 한다.
- 프로세스들은 유한한 시간 안에 자원을 반납해야 한다.

은행원 알고리즘은 엄청나게 복잡하기 때문에 프로그램에 적용하기가 어렵고 오버헤드가 너무 크다. 그래서 현재 채택하고 있는 방식은 아니다.



## 참고 링크

> [교착상태(데드락 Deadlocks 정의 및 예시) - 양햄찌가 만드는 세상](https://jhnyang.tistory.com/2?category=815411)
>
> [교착상태(데드락 Deadlocks)의 발생조건 - 양햄찌가 만드는 세상](https://jhnyang.tistory.com/3?category=815411)
>
> [교착상태 처리방법, 해결 방안 - 양햄찌가 만드는 세상](https://jhnyang.tistory.com/4?category=815411)
>
> [교착상태 회피(은행원 알고리즘), 안전상태, 불안정상태 - 양햄찌가 만드는 세상](https://jhnyang.tistory.com/102?category=815411)

