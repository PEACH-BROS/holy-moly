# JVM에 대해 아는만큼 설명해주세요.

[비밥의 JVM](bebop.md)

[코일의 JVM](coyle-jvm.md)

[엘리의 JVM](elly-jvm.md)



---

## JVM의 구조

![image](https://user-images.githubusercontent.com/13347548/83965962-7499a600-a8f2-11ea-828e-f95d70be01cc.png)

>  The main components of the JVM include the classloader, the runtime data areas, and the execution engine.

크게 **클래스 로더**, **런타임 데이터 영역**, **실행 엔진**으로 나뉜다.



## 클래스 로더 

`.class` 에서 바이트 코드를 읽어 메모리에 저장한다.

- 로딩 : class를 읽어오는 과정
- 링크 : class간의 레퍼런스를 연결하는 과정
- 초기화 : static 값의 초기화 및 변수에 할당하는 과정



## 런타임 데이터 영역

메모리 영역은 클래스 수준의 정보를 저장, 공유한다.  
클래스 수준의 정보 : 클래스 이름, 부모 클래스의 이름, 메소드, 변수



- 스택 : 쓰레드 마다 런타임 스택을 만들고, 그 내부에 메소드 호출 스택을 스택 프레임이라는 이름으로 블럭을 쌓는다.  
  쓰레드가 종료되면 런타임 스택은 사라진다.
- PC 레지스터 : Program Counter, 쓰레드마다 현재 실행할 스택 프레임을 가리키는 포인터이다.
- 네이티브 메소드 스택 : 네이티브가 의미하는 것은 자바 외의 언어로 작성된 코드(C, C++)을 의미한다.  
  JNI를 통해 호출하는 코드를 수행하기 위한 스택이다.
- 힙 : 객체를 저장 공유한다.
- 메소드 : 공유 메모리 영역, 모든 쓰레드에게 공유가 된다. static 키워드가 붙은 자원들을 관리한다.  
  메소드의 바이트 코드 또한 같이 저장된다.



모든 쓰레드가 공유하는 영역 : 힙, 메소드

쓰레드마다 한 개씩 생성되는 영역 : 스택, PC 레지스터, 네이티브 메소드 스택



## 실행 엔진

클래스 로더에 의해 로드된 바이트 코드를 실행하는 Runtime 모듈이다.

(클래스 로더가 JVM 내의 런타임 데이터 영역에 바이트 코드를 배치 시키고 이것은 실행 엔진에 의해 실행된다.)

- 인터프리터 : 바이트 코드를 한 줄 씩 실행한다.
- JIT 컴파일러 : 인터프리터의 효율을 높여준다. 인터프리터가 반복되는 코드를 발견하면 JIT 컴파일러가 반복되는 코드를 네이티브 코드로 바꾸고 인터프리터가 미리 컴파일 된 코드를 사용한다.
- GC : 더 이상 참조되지 않는 객체의 메모리를 수거한다, 런타임 데이터 영역의 힙 영역의 메모리를 관리한다.



---







> 오늘의 이슈

- JVM은 컴파일 타임에 실행되나?

  자바의 컴파일 과정 : 자바파일 -> 클래스파일 -> 바이너리 파일 까지 합쳐서 볼 수도 있는 것 같다.

  크게 봤을 떄, 컴파일 과정 내에 jvm 실행 과정도 포함되어 있다.

- ARM 아키텍쳐 같은 하드웨어는 레지스터 기반으로 동작하는데 JVM은 스택 기반으로 동작한다.

  **그렇다면, JVM은 왜 스택 기반일까?** 하드웨어 의존성을 줄이기 위해. (자바의 철학 중 WORA 참고)

- 안드로이드 JVM은 스택이 아닌 레지스터 기반이다. 요놈이 더 빠르다!

  스택은 push pop 연산 과정이 필요한데, 레지스터는 그런 연산 과정이 없어서 더 빠르다.

