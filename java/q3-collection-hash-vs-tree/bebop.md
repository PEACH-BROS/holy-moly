# hash와 tree의 차이를 설명해보세요.

### Hash

Hash로 이루어진 컬렉션의 경우 내부에 Hash값을 저장하는 `Node`배열이 존재하고 있다.

![image](https://user-images.githubusercontent.com/13347548/84895254-05d00000-b0dd-11ea-8a41-97bccd541e5a.png)

따라서 객체의 `hashcode()` 메서드로 hash값을 추출한 뒤 배열에 접근하기 때문에 시간복잡도가 `O(1)`이 된다.

이때 hash값의 충돌이 일어난다면 linked list 형태로 이루어진 V를 탐색하기 때문에 시간복잡도는 O(n)이 된다.

### Tree

Tree로 이루어진 컬렉션의 경우 내부에 엔트리로 이루어진 노드를 가지고 있다. 

![image](https://user-images.githubusercontent.com/13347548/84894857-7de9f600-b0dc-11ea-879f-0937c55f08f6.png)

이진 탐색을 이용하기 때문에 시간 복잡도가 `O(logN)`이 된다.  

### 어떤걸 쓰지?

보통 컬렉션 내부에 아이템이 적으면 hash의 성능이 좋고, 아이템이 많으면 tree가 성능이 더 좋은편이다.

그렇다면 아이템이 적다는 것과 많다는 것을 어떻게 비교할 수 있을까?

아이템이 적고 많고는 해당 컬렉션의 수용량에 따라 달라진다.

따라서 적다는 것을 의미하는 것은 컬렉션의 수용량이 5일때 5개 이하의 컬렉션 아이템을 가지고 있다면,  
즉, 해시값의 충돌이 발생하지 않는다면 hash를 사용하는 것이 시간복잡도 `O(1)`을 보장해주기 때문에 빠르다.