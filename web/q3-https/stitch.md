# HTTPS의 동작 방식에 대하여

## HTTP : HyperText Transfer Protocol

web 상에서 정보를 주고 받을 수 있는 **통신규약**이다. 주로 HTML 문서를 주고받을 때 사용한다.

TCP와 UDP를 사용하며 80번 포트를 사용한다.

HTTP는 **암호화되지 않은 방법**으로 데이터를 전송하기 때문에 서버와 클라이언트가 주고 받는 메시지를 감청하는 것이 매우 쉽다. 

예를 들어 로그인을 위해서 서버로 비밀번호를 전송하거나, 또는 중요한 기밀 문서를 열람하는 과정에서 악의적인 감청이나 데이터의 변조등이 일어날 수 있다는 것이다. 이를 보안한 것이 **HTTPS**다.

## HTTPS : HyperText Transfer Protocol over Secure Socket Layer

HTTPS는 SSL 프로토콜을 기반으로 돌아가는 프로토콜 중 하나다.

키를 교환하는 곳에서는 공개키 암호를 사용하고 그 후 통신에서 메시지를 교환하는 곳에서는 대칭키를 사용한다.



### SSL : Secure Socket Layer

SSL과 TLS는 같은 뜻으로 말하며 TLS1.0은 SSL3.0을 계승한다.

SSL 인증서란 클라이언트와 서버간의 통신을 **제 3자가 보증을 해주는 문서**이다.

SSL를 사용하면 좋은 점으로는

- 통신 내용이 공격자에게 노출되는 것을 막을 수 있다. 
- 클라이언트가 접속하려는 서버가 신뢰 할 수 있는 서버인지를 판단할 수 있다.
- 통신 내용의 악의적인 변경을 방지할 수 있다. 



### 대칭키

동일한 키로 암호화와 복호화를 같이 할 수 있는 방식의 암호화 기법을 의미한다.

단점으로는 암호를 주고 받는 사람들 사이에 대칭키를 전달하는 것이 어렵다는 점이다. 대칭키가 유출되면 키를 획득한 공격자는 암호의 내용을 복호화 할 수 있기 때문에 암호가 무용지물이 되기 때문이다.

이런 배경에서 나온 암호화 방식이 공개키 방식이다.



### 공개키

두 개의 키를 갖게 되는데 A키로 암호화를 하면 B키로 복호화를 할 수 있고, B키로 암호화를 하면 A키로 복호화를 할 수 있는 방식이다.

이 방식에 착안해서 두 개의 키 중 하나를 개인키(private key, 비밀키)로 하고, 나머지를 공개키(public key)로 지정한다.

개인키는 자신만이 가지고 있고, 공개키를 타인에게 제공한다. 공개키를 제공 받은 타인은 공개키를 이용해서 정보를 암호화한다. 암호화한 정보를 비공개키를 가지고 있는 사람에게 전송한다. 비공개키의 소유자는 이 키를 이용해서 암호화된 정보를 복호화한다. 이 과정에서 공개키가 유출된다고 해도 비공개키를 모르면 정보를 복호화 할 수 없기 때문에 안전하다.

개인키의 소유자는 개인키를 이용해서 정보를 암호화 한 후에 공개키와 함께 암호화된 정보를 전송한다. 정보와 공개키를 획득한 사람은 공개키를 이용해서 암호화된 정보를 복호화 한다. 

이는 공개키를 획득한 공격자에 의해서 데이터가 복호화될 위험이 있다. 그러나 이 방식은 데이터를 보호하는 것이 목적이 아니다. 암호화된 데이터를 공개키를 가지고 복호화 할 수 있다는 것은 그 데이터가 공개키와 쌍을 이루는 개인키에 의해서 암호화 되었다는 것을 의미한다.

즉 공개키가 데이터를 제공한 사람의 신원을 보장해주게 되는 것이다. 이를 **전자 서명**이라고 부른다.



### SSL 인증서

인증서의 기능은 크게 두 가지다.

- 클라이언트가 접속한 서버가 신뢰 할 수 있는 서버임을 보장한다.
- SSL 통신에 사용할 공개키를 클라이언트에게 제공한다.

그리고 인증서에는 다음과 같은 정보가 포함되어 있다.

1. 서비스의 정보 (인증서를 발급한 CA, 서비스의 도메인 등)
2. 서버 측 공개키 (공개키의 내용, 공개키의 암호화 방법)

1번은 클라이언트가 접속한 서버가 클라이언트가 의도한 서버가 맞는지에 대한 내용을, 2번은 서버와 통신을 할 때 사용할 공개키와 그 공개키의 암호화 방법들의 정보를 담고 있다. 서비스의 도메인, 공개키와 같은 정보는 서비스가. CA로부터 인증서를 구입할 때 제출해야 한다.

위와 같은 내용은 CA에 의해서 암호화 된다. 이 때 사용하는 암호화 기법이 공개키 방식이다. CA는 자신의 CA 개인키를 이용해서 서버가 제출한 인증서를 암호화하는 것이다. 브라우저는 CA의 리스트를 미리 파악하고 있고 CA의 공개키를 미리 알고 있다. 서버가 보낸 인증서가 본인이 가지고 있는 CA의 공개키로 복호화가 된다면 신뢰할 수 있는 서버라고 생각한다.



## SSL 통신 방식

### 1. 악수 (handshake)

Handshake를 통해 서로 상대방이 존재하는지, 또 상대방과 데이터를 주고 받기 위해서는 어떤 방법을 사용해야하는지를 파악한다. 그리고 이 과정을 통해 상대방의 신원을 확인한다.

1. 클라이언트가 서버에 접속한다. 이 단계를 Client Hello라고 한다. 이 단계에서 주고 받는 정보는 아래와 같다.

   - 클라이언트 측에서 생성한 랜덤 데이터 : 아래 3번 과정 참조
   - 클라이언트가 지원하는 암호화 방식들 : 클라이언트와 서버가 지원하는 암호화 방식이 서로 다를 수 있기 때문에 상호간에 어떤 암호화 방식을 사용할 것인지에 대한 협상을 해야 한다. 이 협상을 위해서 클라이언트 측에서는 자신이 사용할 수 있는 암호화 방식을 전송한다.
   - 세션 아이디 : 이미 SSL 핸드쉐이킹을 했다면 비용과 시간을 절약하기 위해서 기존의 세션을 재활용하게 되는데 이 때 사용할 연결에 대한 식별자를 서버 측으로 전송한다.

2. 서버는 Client Hello에 대한 응답으로 Server Hello를 하게 된다. 이 단계에서 주고 받는 정보는 아래와 같다.

   - 서버 측에서 생성한 랜덤 데이터 : 아래 3번 과정 참조
   - 서버가 선택한 클라이언트의 암호화 방식 : 클라이언트가 전달한 암호화 방식 중에서 서버 쪽에서도 사용할 수 있는 암호화 방식을 선택해서 클라이언트로 전달한다. 이로써 암호화 방식에 대한 협상이 종료되고 서버와 클라이언트는 이 암호화 방식을 이용해서 정보를 교환하게 된다.
   - 인증서

3. 클라이언트는 서버의 인증서가 CA에 의해서 발급된 것인지를 확인하기 위해서 클라이언트에 내장된 CA 리스트를 확인한다. CA 리스트에 인증서가 없다면 사용자에게 경고 메시지를 출력한다.

   인증서가 CA에 의해서 발급된 것인지를 확인하기 위해서 클라이언트에 내장된 CA의 공개키를 이용해서 인증서를 복호화한다. 복호화에 성공했다면 인증서는 CA의 개인키로 암호화된 문서임이 암시적으로 보증된 것이다. 인증서를 전송한 서버를 믿을 수 있게 된 것이다.

   클라이언트는 상기 2번을 통해서 받은 서버의 랜덤 데이터와 클라이언트가 생성한 랜덤 데이터를 조합해서 pre master secret라는 키를 생성한다. 이 키는 뒤에서 살펴볼 세션 단계에서 데이터를 주고 받을 때 암호화하기 위해서 사용될 것이다. 이 때 사용할 암호화 기법은 대칭키이기 때문에 pre master secret 값은 제 3자에게 절대로 노출되어서는 안된다.

   그럼 문제는 이 pre master secret 값을 어떻게 서버에게 전달할 것인가이다. 이 때 사용하는 방법이 바로 공개키 방식이다. 서버의 공개키로 pre master secret 값을 암호화해서 서버로 전송하면 서버는 자신의 비공개키로 안전하게 복호화 할 수 있다. 그럼 서버의 공개키는 어떻게 구할 수 있을까? 서버로부터 받은 인증서 안에 들어있다. 이 서버의 공개키를 이용해서 pre master secret 값을 암호화한 후에 서버로 전송하면 안전하게 전송할 수 있다.

4. 서버는 클라이언트가 전송한 pre master secret 값을 자신의 비공개키로 복호화한다. 이로서 서버와 클라이언트가 모두 pre master secret 값을 공유하게 되었다. 그리고 서버와 클라이언트는 모두 일련의 과정을 거쳐서 pre master secret 값을 master secret 값으로 만든다. master secret는 session key를 생성하는데 이 session key 값을 이용해서 서버와 클라이언트는 데이터를 대칭키 방식으로 암호화 한 후에 주고 받는다. 이렇게해서 세션키를 클라이언트와 서버가 모두 공유하게 되었다는 점을 기억하자.

5. 클라이언트와 서버는 핸드쉐이크 단계의 종료를 서로에게 알린다.

### 2. 세션

세션은 실제로 서버와 클라이언트가 데이터를 주고 받는 단계이다. 이 단계에서 핵심은 정보를 상대방에게 전송하기 전에 session key 값을 이용해서 대칭키 방식으로 암호화 한다는 점이다. 암호화된 정보는 상대방에게 전송될 것이고, 상대방도 세션키 값을 알고 있기 때문에 암호를 복호화 할 수 있다.

그냥 공개키를 사용하면 될 것을 대칭키와 공개키를 조합해서 사용하는 이유는 무엇을까? 그것은 공개키 방식이 많은 컴퓨터 파워를 사용하기 때문이다. 만약 공개키를 그대로 사용하면 많은 접속이 몰리는 서버는 매우 큰 비용을 지불해야 할 것이다. 반대로 대칭키는 암호를 푸는 열쇠인 대칭키를 상대에게 전송해야 하는데, 암호화가 되지 않은 인터넷을 통해서 키를 전송하는 것은 위험하기 때문이다. 그래서 속도는 느리지만 데이터를 안전하게 주고 받을 수 있는 공개키 방식으로 대칭키를 암호화하고, 실제 데이터를 주고 받을 때는 대칭키를 이용해서 데이터를 주고 받는 것이다.

### 3. 세션종료

데이터의 전송이 끝나면 SSL 통신이 끝났음을 서로에게 알려준다. 이 때 통신에서 사용한 대칭키인 세션키를 폐기한다.



## 참고 링크

> [HTTP와 HTTPS의 차이점 그리고 동작 방식 - D.young](https://devdy.tistory.com/14)
>
> [HTTPS와 SSL 인증서 - 생활코딩](https://opentutorials.org/course/228/4894)
>
> [HTTP와 SSL에 대한 기본 개념 및 통신과정 - Ailyn](https://aileen93.tistory.com/119)

