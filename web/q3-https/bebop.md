# HTTPS는 어떻게 동작하나요?

HTTPS 는 HTTP + SSL 로 이루어져 있다.

HTTP는 Hypertext Transfer Protocol. 즉, 전송 규약을 나타낸다.  
SSL은 Secure Socket Layer. 소켓 보안 계층을 의미한다.

따라서 HTTPS 는 전송규약에 보안 계층을 추가한 것이라 볼 수 있다.

보안 계층을 추가한 이유는 HTTP가 암호화 되지 않은채로 정보를 송수신 하기 때문이다.  
따라서 HTTPS 는 송수신 하는 정보를 모두 암호화 하여 다룬다.

*두 프로토콜의 차이를 그림으로 나타내면 아래 그림과 같다.*

![image](https://user-images.githubusercontent.com/13347548/85761480-c2fdd000-b74d-11ea-91bd-89cd9143226e.png)

결국 SSL이 어떻게 동작하는지가 관건이다.

## SSL

SSL의 핵심은 SSL 인증서에 있다.  
인증서는 클라이언트와 서버간의 통신을 공인된 제 3자가 보증해주는 문서를 뜻한다.

SSL 인증서의 역할은 다음과 같다.

- 통신 내용의 노출, 변경 방지
- 클라이언트가 접속하려는 서버의 신뢰도 확인
- SSL 통신에 사용될 공개키를 클라이언트에게 제공

### 암호화

대칭키보다 공개키가 보다 더 안전하지만 공개키만 사용하기에는 비용이 크기 때문에 **대칭키와 공개키를 혼용**해서 사용한다.

**클라이언트가** 서버를 신뢰할 수 있다 판단하면 **대칭키를 만들고** 대칭키를 **공개키 방식을 이용하여 서버에게 전달**한다.  
그리고 **대칭키를 데이터 암호화 복호화에 사용하여 통신**을한다.

#### 대칭키

대칭키 하나로 **암호화와 복호화를 할 수 있다**.

다만, 대칭키 자체를 상대방에게 전달하기가 어렵다는 단점이 있다. 노출되면 망하기 때문이다.

#### 공개키

공개키 방식은 **비공개키, 공개키** 두개의 키를 가지고 시작한다.

비공개키는 자신이 가지고 있고 공개키는 상대방에게 준다.  
**공개키를 이용하여 상대방은 전송할 데이터를 암호화** 하고 **복호화는 비공개키로 수행**하게 된다.

### 통신 주고 받기 : SSL Handshake

1. 클라이언트 : Client Hello 요청

   - 주고 받는 정보
     - 클라이언트 측에서 생성한 랜덤 데이터 : 아래 3번 과정 참조
     - 클라이언트가 지원하는 암호화 방식들 : 서버와 동일한 암호화 방식을 사용하여 통신하기 위해 전달한다.
     - 세션 아이디 : 이미 SSL 핸드쉐이킹을 했다면 자원을 절약하기 위해서 기존의 세션을 재활용하기 위해서 전달
        

2. 서버 : Server Hello 응답

   - 주고 받는 정보
     - 서버 측에서 생성한 랜덤 데이터 : 아래 3번 과정 참조
     - 서버가 선택한 클라이언트의 암호화 방식 : 클라이언트와 동일한 암호화 방식을 사용하여 통신하기 위해 전달한다.  

   

3. 클라이언트는 서버의 인증서가 CA*(공인된 기업)*에 의해서 발급된 것인지를 확인하기 위해서 클라이언트에 내장된 CA 리스트를 확인한다.  
   만약 CA 리스트에 인증서가 없다면 사용자에게 경고 메시지를 출력한다.  
   인증서가 CA에 의해서 발급된 것인지를 확인하기 위해서 클라이언트에 내장된 CA의 공개키를 이용해서 인증서를 복호화한다.  
   복호화에 성공했다면 인증서는 CA의 개인키로 암호화된 문서임이 암시적으로 보증된 것이다.  
   인증서를 전송한 서버를 믿을 수 있게 된 것이다.

   **클라이언트는 서버의 랜덤 데이터와 클라이언트가 생성한 랜덤 데이터를 조합해서 pre master secret라는 키를 생성**한다.  
   이 키는 세션 단계에서 데이터를 주고 받을 때 암호화하기 위해서 사용된다.  
   이 때 사용할 암호화 기법은 **대칭키이기 때문에 pre master secret 값은 제 3자에게 절대로 노출되어서는 안된다.**
   pre master secret 값을 **서버에게 전달하는 방법은 공개키 방식**이다.  
   서버의 공개키로 pre master secret 값을 암호화해서 서버로 전송하면 서버는 자신의 비공개키로 안전하게 복호화 할 수 있다.  
   그럼 서버의 공개키는 서버로부터 받은 인증서 안에 들어있다.  
   서버의 공개키를 이용해서 pre master secret 값을 암호화한 후에 서버로 전송하면 안전하게 전송할 수 있다.

4. 서버는 클라이언트가 전송한 pre master secret 값을 자신의 **비공개키로 복호화**한다.  
   이제 서버와 클라이언트가 모두 pre master secret 값을 공유하게 되었다.  
   서버와 클라이언트는 모두 일련의 과정을 거쳐서 pre master secret 값을 master secret 값으로 만든다.  
   **master secret는 session key를 생성**한다.  
   **session key 값을 이용**해서 서버와 클라이언트는 **데이터를** **대칭키 방식으로 암호화 한 후에 주고 받는다**.  

   

5. 클라이언트와 서버는 핸드쉐이크 단계의 종료를 서로에게 알린다.

---

> 참고

https://aileen93.tistory.com/119

https://wayhome25.github.io/cs/2018/03/11/ssl-https/

https://opentutorials.org/course/228/4894