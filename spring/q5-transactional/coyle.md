# @Transactional



## I said

스프링에서 트랜잭션을 적용시키는 어노테이션으로 AOP로 구현되어 있다. 트랜잭션이 실행되는 로직과 트랜잭션을 커밋하는 로직등을 aspect로 분류하여 구현하였습니다. 스프링에서는 위 어노테이션을 구현하기 위해 프록시 패턴을 사용한 것으로 알고 있습니다.



## 트랜잭션의 성질



**▶ 원자성(Atomicity)**

 \- 한 트랜잭션 내에서 실행한 작업들은 하나로 간주한다. 즉, 모두 성공 또는 모두 실패. 

**▶ 일관성(Consistency)**

 \- 트랜잭션은 일관성 있는 데이타베이스 상태를 유지한다. (data integrity 만족 등.)

**▶ 격리성(Isolation)**

 \- 동시에 실행되는 트랜잭션들이 서로 영향을 미치지 않도록 격리해야한다.

**▶ 지속성(Durability)**

 \- 트랜잭션을 성공적으로 마치면 결과가 항상 저장되어야 한다.



## @Transaction



스프링에서는 어노테이션 방식으로 트랜잭션 처리를 지원한다. 클래스, 메서드 위에 @Transactional이 추가되면 트랜잭션 기능이 적용된 프록시 객체가 생성되고 이 프록시 객체는 PlatformTransactionManager를 사용하여 트랜잭션을 시작하고, 정상 여부에 따라 커밋 혹은 롤백한다.



## 다수의 트랜잭션이 경쟁시 발생할 수 있는 문제



▶ Problem1 - Dirty Read

▶ Problem2 - Non-Repeatable Read

▶ Problem3 - Phantom Read



## 트랜잭션 격리 수준

- 트랜잭션에서 일관성이 없는 데이터를 허용하도록 하는 수준을 말한다.



**▶ DEFAULT**

기본 격리 수준(기본설정, DB의 Isolation Level을 따름)

▶ READ_UNCOMMITTED (level 0) - Dirty Read 발생

▶ READ_COMMITTED (level 1) - Dirty Read 방지

▶ REPEATABLE_READ (level 2) - Non-Repeatable Read 방지

▶ SERIALIZABLE (level 3) - Phantom Read 방지



```java
@Transactional(isolation=Isolation.DEFAULT)
public void something (int a) {
    …
}
```



## 트랜잭션 Propagation (전파 옵션)



트랜잭션 동작 도중 다른 트랜잭션을 호출(실행)하는 상황이에 선택할 수 있는 옵션이다.

**@Transactional**의 **propagation** 속성을 통해 피호출 트랜잭션의 입장에서는 호출한 쪽의 트랜잭션을 그대로 사용할 수도 있고, 새롭게 트랜잭션을 생성할 수도 있다.



**▶ REQUIRED**

 \- 디폴트 속성, 부모 트랜잭션 내에서 실행하며 부모 트랜잭션이 없을 경우 새로운 트랜잭션을 생성한다.



**▶ SUPPORTS**

 \- 이미 시작된 트랜잭션이 있으면 참여하고 그렇지 않으면 트랜잭션 없이 진행하게 만든다. 



**▶ REQUIRES_NEW**

 \- 부모 트랜잭션을 무시하고 무조건 새로운 트랜잭션이 생성



**
**

**▶ MANDATORY**

 \- REQUIRED와 비슷하게 이미 시작된 트랜잭션이 있으면 참여한다. 

 \- 반면에 트랜잭션이 시작된 것이 없으면 새로 시작하는 대신 예외를 발생시킨다. 

 \- 혼자서는 독립적으로 트랜잭션을 진행하면 안 되는 경우에 사용한다.



**
**

**▶ REQUIRES_NEW**

 \- 항상 새로운 트랜잭션을 시작한다.

 \- 이미 진행 중인 트랜잭션이 있으면 트랜잭션을 잠시 보류시킨다.



**
**

**▶ NOT_SUPPORTED**

 \- 트랜잭션을 사용하지 않게 한다.

 \- 이미 진행 중인 트랜잭션이 있으면 보류시킨다.





**▶ NEVER**

 \- 트랜잭션을 사용하지 않도록 강제한다.

 -0 이미 진행 중인 트랜잭션도 존재하면 안된다 있다면 예외를 발생시킨다.



**▶ NESTED**

 \- 이미 진행중인 트랜잭션이 있으면 중첩 트랜잭션을 시작한다.

 \- 중첩 트랜잭션은 트랜잭션 안에 다시 트랜잭션을 만드는 것이다.



 \- 하지만 독립적인 트랜잭션을 만드는 REQUIRES_NEW와는 다르다.



중첩된 트랜잭션은 먼저 시작된 부모 트랜잭션의 커밋과 롤백에는 영향을 받지만 자신의 커밋과 롤백은 부모 트랝개션에게 영향을 주지 않는다.



\1. 어떤 작업을 진행하는 중 로그는 꼭 DB에 저장해야 할 때

이 로그를 저장하는 작업이 실패한다고 메인 작업의 트랜잭션까지는 롤백되버린다면 특히 쇼핑몰에서 고객 주문작업 등의 경우 매출 하락까지도 발생할 수 있는 중요한 문제이다.



반대로 로그를 남긴 후 메인 작업에서 예외가 발생한다면 이때는 저장한 로그도 롤백 되어야 하는게 맞다.



이럴 때 로그 작업을 메인 트랜잭션에서 분리해서 중첩 트랜잭션으로 만들어 두면 유용하게 사용할 수 있다. 이렇게 때문에 더욱 더 Business 로직을 잘 짜줘야 할 것이다.



중첩 트랜잭션은 JDBC 3.0 스펙의 저장포인트(savepoint) **[(클릭시 자세한 내용링크)](http://goddaehee.tistory.com/162)** 를 지원하는 드라이버와 DataSourceTransactionManager 를 이용할 경우에 적용 가능하다.



**ex)**

```
public void something (int a) {
    …
}
```





**[ 3. readOnly 속성 ]**



 \- 트랜잭션을 읽기 전용으로 설정할 수 있다.



 \- 성능을 최적화하기 위해 사용할 수도 있고 특정 트랜잭션 작업 안에서 쓰기 작업이 일어나는 것을 의도적으로 방지하기 위해 사용할 수도 있다. 



 \- 일부 트랜잭션 매니저의 경우 읽기전용 속성을 무시하고 쓰기 작업을 허용할 수도 있기 때문에 주의해야 한다. 



 \- 일반적으로 읽기 전용 트랜잭션이 시작된 이후 INSERT, UPDATE, DELETE 같은 쓰기 작업이 진행되면 예외가 발생한다. 



 \- @Transactional 의 경우는 각 메소드에 일일이 읽기 전용 지정을 해줘야 한다.

  read-only 애트리뷰트 또는 readOnly 앨리먼트로 지정한다.

  true인 경우 insert, update, delete 실행 시 예외 발생, 기본 설정은 false





ex)`@Transactional(readOnly = true)`