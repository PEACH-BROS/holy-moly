# 인덱스

나의 답변 : 

---

쉽게 말해, 책의 맨 마지막에 있는 *색인*이다.

<br/>

- SELECT(검색) 쿼리 시 동작 속도를 높여주는 *자료구조*.

- 테이블에 index를 생성하게 되면, **index 테이블**을 생성해 관리한다.
- 한 테이블에 여러 개의 index를 만들 수 있다.

- 보통 **컬럼의 값 : 해당 레코드가 저장된 주소** (키 : 값) 형태로 이루어져 있다.
- B-Tree 인덱스, Hash 인덱스가 대표적이다.

<br/>

인덱스는 최대한 빠르게 찾아갈 수 있게 (마치 색인이 ㄱ, ㄴ, ㄷ 순인 것처럼) 항상 정렬된 상태를 유지한다. 원하는 값을 탐색(SELECT)할 때는 빠르지만, 새로운 값을 추가/삭제/수정할 때는 쿼리 실행 속도가 느려진다.

❗️ 결국, 인덱스는 데이터의 WRITE(쓰기) 성능을 희생하고, READ(읽기) 속도를 높이는 기능이다.

<br/>

---

### 인덱스 생성 방법

```sql
CREATE INDEX CUSTOMERS_INDEX ON CUSTOMERS(NAME, ADDRESS); 
```

-> B-Tree 등과 같은 알고리즘을 하나 사용해 인덱스가 하나 만들어진다.

<br/>

또 만들 수 있다! 검색만이 목적이 아니라 정렬, 그룹핑을 위한 인덱스 생성도 존재한다.

```sql
CREATE INDEX CUSTOMERS_INDEX_2 ON CUSTOMERS(COUNTRY); 
```

-> 실제 데이터의 종류는 100만 건이지만, COUNTRY의 개수는 10개인 경우.

<br/>

---

### 인덱스(= 키)를 역할별로 구분한다면...?

1. **Primary Key**

   그 행을 대표하는 컬럼의 값으로 만들어진 인덱스.

   이 컬럼(때로는 컬럼의 조합)은 테이블에서 해당 레코드를 식별할 수 있는 기준값이 되기 때문에 식별자라고 부르기도 한다.

   NOT NULL + UNIQUE 해야 한다.

2. **Secondary Key (보조 키)** : PK를 제외한 나머지 모든 키

   그 중, UNIQUE한 인덱스는 프라이머리 키와 성격이 비슷하고, 대체해 사용할 수도 있다고  해서 대체 키라고 하기도 한다.

   (UNIQUE하지 않은 인덱스도 존재한다. BUT, UNIQUE한 인덱스라면 실제 DBMS 쿼리를 실행하는 옵티마이저에게 "같은 값을 1개만 찾으면 더이상 찾지 않아도 돼" 하고 알려주는 꼴이다. 따라서 성능은 UNIQUE한 인덱스가 훨씬 좋다.)

<br/>

---

### 인덱스에서 사용하는 알고리즘

1. **B-Tree(Balanced Tree) 인덱스**

   가장 많이 사용된다.

   컬럼의 원래 값을 변형하지 않고, 값의 앞부분만 잘라서 인덱스 구조체 내에서 항상 정렬된 상태를 유지한다.

   원래 값을 이용해 인덱싱한다.

   키 값이 정렬되어 있지만, 데이터 파일의 레코드는 정렬되어 있지 않다.

   🤔 왜 페이지로 나뉘어 있는지는 모르겠다.

   ![image](https://user-images.githubusercontent.com/19922698/89736501-c69ea980-daa4-11ea-8a4a-9bb7aabd844d.png)

2. **Hash 인덱스**

   컬럼의 값으로 해시 값을 계산해 인덱싱한다. 매우 빠른 검색을 지원한다.

3. **Fractal-Tree 인덱스**

   B-Tree의 단점 보완. 마찬가지로 값 변형 없다. 근데 데이터 저장/삭제될 때 처리 비용이 상당히 줄어든다.

<br/>

---

### 클러스터링 인덱스  

**클러스터링** : 여러 개를 하나로 묶는다.

**클러스터링 인덱스** : 값이 비슷한 것들을 묶어서 저장한다. 정확히 말하면, PK 값이 비슷한 레코드끼리 묶어서 저장하는 것.

(🤔 비슷한 값들을 동시에 조회하는 경우가 많다는 점에서 착안했다.)



PK 값에 의해 레코드의 저장 위치가 결정된다. 또, PK 값이 바뀌면 물리적인 저장 위치도 바뀐다.

InnoDB는 항상 클러스터링 인덱스로 저장된다. PK 기반 검색이 매우 빠르고, 대신 레코드 저장이나 프라이머리 키의 변경이 상대적으로 느릴 수밖에 없다.



### 클러스터 키 선택 기준? (InnoDB 테이블에서는...)

1. PK가 있으면 PK를 클러스터 키로 선택

2. NOT NULL 옵션의 UNIQUE 인덱스 중에서 첫 번째 인덱스를 클러스터 키로 선택

3. 자동 증가 컬럼을 내부적으로 추가해서 클러스터 키로 선택





<br/>

> 참고
>
> [인덱스 위키](https://ko.wikipedia.org/wiki/인덱스_(데이터베이스))  
> https://k39335.tistory.com/26  
> https://coding-factory.tistory.com/419  
> Real MySQL 5장 인덱스