# 트랜잭션 고립 수준에 대해 설명해보세요

### 트랜잭션이란 ?

데이터에 대한 하나의 논리적 실행 단계이다.

### 트랜잭션 ACID란 ? => DB의 신호등

- 원자성 (Atomicity) : 한 트랜잭션 내 All or Nothing
- 일관성 (Consistency) : 모든 트랜잭션은 일관성 있는(무결성 조건)DB 상태를 유지
- 격리성 (Isolation) : 서로 영향 X를 위해 동시 실행 트랜잭션 격리
- 지속성 (Duration) : 트랜잭션 성공 => 결과 항상 저장



### 격리성 이슈



> **트랜잭션들끼리 영향을 주지 않기 위해** 격리성이 존재한다는 사실을 짚고 돌아가자.



 격리성 보장을 위해 모든 트랜잭션을 순차적으로 실행

- 동시성 처리 이슈 발생

반대로 동시성을 높이기 위해 여러 트랜잭션 병렬처리

- 데이터의 무결성이 깨질 수 있다.



> 예를 찾아보자.



### 격리성 관련 문제점

**Dirty Read**

1. 트랜잭션 T1이 값을 A를 B로 변경하고 아직 커밋 하지 않았을 때
2. 트랜잭션 B가 값을 조회하면 B가 조회된다.
3. T1이 최종 커밋을 하지 않고 종료하면, T2가 가진 데이터는 꼬이게 된다.

- 요약 : 커밋되기 전 데이터를 조회하면 커밋이 될지 안될지 모르므로 문제가 발생할 수 있다.
- 해결 방안 : **공유 Lock**을 걸어서 T1이 A에 접근하고 있는 동안 다른 트랜잭션이 접근 못하게한다.

**Non-Repeatable Read**

1. T1 트랜잭션이 같은 쿼리를 두 번 수행 시 첫번째 수행 시와 값이 다른 쿼리가 존재하는 것

- 요약 : 한 트랜잭션이 SELECT을 두 번 하는 사이에 다른 트랜잭션이 UD하는 경우
- 해결 방안 : 트랜잭션 완료시까지 **수정/삭제** 제한

**Pahntom Read**

1. T1 트랜잭션이 같은 쿼리를 두 번 수행 시 첫번째 수행시에 없던 레코드가 두번째 실행시에 튀어나오는 경우

- 요약 : Diry Read의 다중 검색 조건화
- 해결 방안 : 트랜잭션 완료시까지 수정/삭제/**삽입** 제한



### 아니, 면접자님... 트랜잭션 격리 수준이 뭐냐구요! 이상한 소리 쏟아내시네;;

 결국 격리성과 동시 처리 성능은 서로 트레이드 오프인데 이를 4단계로 나눠 '트랜잭션 격리수준'이라고 칭한다.

> 트랜잭션 시나리오가 같은데도 결과가 다를 수 있는 4가지 트랜잭션 고립 수준

 내려갈수록 격리 수준이 높아져서 위에서 언급된 문제들이 적게 발생하지만 동시 처리 성능은 떨어진다. 

> 트랜잭션이 발생하면 락(Lock)이 걸리는데, SELCET 시에는 **공유 락**, CREATE/INSERT/DELETE시에는 **배타적 락**이 걸린다.
>
> // 요놈 이고 CUD말하는 것 같은딩;;



1. Read Uncomiitted

- 다른 트랜잭션이 커밋하지 않은 데이터를 읽을 수 있다.
- 발생 문제점 : Dirty Read, Non-Repeatable Read, Phantom Read

2. Read Committed

- 커밋이 완료된 데이터만 읽을 수 있다.
- DB들은 Read Committed이 디폴트
- 발생 문제점 : Non-Repeatable Read, Phantom Read

3. Repeatable Read

- 트랜잭션 내에서 한번 조회한 데이터를 반복해서 조회해도 같은 데이터가 조회
- 선택 트랜잭션 T1이 읽은 데이터는 T1이 종료될 때까지는 다른 트랜잭션이 수정/삭제(Update/Delete를 허용하지 않는다.)
- 단 삽입은 허용한다.
- 개별 데이터 이슈인 Dirty Read, Non-Repeatable Read는 발생하지 않지만, 결과 집합 자체가 달라지는 Phantom Read는 발생가능
- 발생 문제점 : Phantom Read

4. Serializable

- 선행 트랜잭션 T1이 읽은 데이터는 T가 종료될 때 까지 다른 트랜잭션이 수정/삭제는 물론 **삽입까지 허용하지 않는다.**
- 모두 커버 가능하다.
- (완벽하지만 실제 현실적으로는 불가능에 가깝다.)



### 공유 락, 배타적 락

- 여러 개의 트랜잭션들이 하나의 데이터로 동시에 접근하려고 할 때 이를 제어해주는 도구가 바로 Lock
- 공유락
  - 트랜잭션이 읽기를 할 때 사용하는 락
  - 참조는 할 수 있고 변경은 할 수 없f다.
- 배타락
  - 읽고 쓰기를 할 때 사용하는 락
  - 참조도 변경도 할 수 없다.
- 락이 걸린 상태에서 데이터를 참조할 수 있느냐 없느냐로 구분된다.
- 락은 트랜잭션이 커밋이나 롤백 되는 시점에 해제된다.

